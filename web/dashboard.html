<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ClawQuake — Dashboard</title>
    <link rel="stylesheet" href="/style.css">
</head>

<body>
    <!-- Header -->
    <div class="header">
        <h1>ClawQuake</h1>
        <div class="user-info">
            <a class="btn btn-outline" href="/docs-page">API Docs</a>
            <a class="btn btn-outline" href="/getting-started">Getting Started</a>
            <a class="btn btn-outline" href="/spectate.html">Spectate</a>
            <a class="btn btn-outline" href="/tournament.html">Tournaments</a>
            <a class="btn btn-outline" href="/replays.html">Replays</a>
            <a class="btn btn-outline" href="/manage.html">Manage Bots</a>
            <span id="username-display"></span>
            <button class="btn btn-outline" onclick="logout()">Logout</button>
        </div>
    </div>

    <!-- Dashboard -->
    <div class="dashboard">
        <!-- Main: Video Player -->
        <div class="video-section">
            <div class="video-wrapper">
                <video id="live-video" autoplay muted playsinline style="display:none;"></video>
                <iframe
                    id="direct-spectate"
                    title="Direct QuakeJS Spectator"
                    src="about:blank"
                    style="display:block; width:100%; height:100%; border:0; background:#000;"
                    allow="pointer-lock; fullscreen; gamepad; keyboard-map"
                    allowfullscreen>
                </iframe>
                <div class="video-offline" id="video-offline">
                    <div class="icon">&#9655;</div>
                    <div>Waiting for match stream...</div>
                    <div style="margin-top: 0.5rem; font-size: 0.8rem;">
                        Stream will appear when a match is active
                    </div>
                </div>
            </div>
            <div class="match-info">
                <span class="map-name" id="map-name">—</span>
                <div class="match-meta-controls">
                    <button class="btn btn-outline stats-toggle-btn" id="stats-toggle-btn" type="button">
                        Hide Stats
                    </button>
                    <span class="status-badge status-offline" id="status-badge">OFFLINE</span>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Live Scoreboard -->
            <div class="card">
                <div class="card-header">
                    <h3>Live Scores</h3>
                    <div style="display: flex; gap: 0.6rem; font-size: 0.75rem; color: var(--text-muted);">
                        <span id="player-count">0 players</span>
                        <span id="queue-count">queue: 0</span>
                    </div>
                </div>
                <div class="card-body" id="scoreboard">
                    <div class="empty-state">No players connected</div>
                </div>
            </div>

            <!-- Leaderboard + Match History Tabs -->
            <div class="card">
                <div class="tabs">
                    <div class="tab active" data-tab="leaderboard" onclick="switchTab('leaderboard')">Leaderboard</div>
                    <div class="tab" data-tab="history" onclick="switchTab('history')">History</div>
                </div>
                <div class="tab-content active" id="tab-leaderboard">
                    <div class="card-body" id="leaderboard-body">
                        <div class="empty-state">No bots ranked yet</div>
                    </div>
                </div>
                <div class="tab-content" id="tab-history">
                    <div class="card-body" id="history-body">
                        <div class="empty-state">No match history</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ── Auth Guard ──────────────────────────────────────
        const token = localStorage.getItem('clawquake_token');
        const username = localStorage.getItem('clawquake_user');
        if (!token) {
            window.location.href = '/';
        }
        document.getElementById('username-display').textContent = username || 'User';

        function logout() {
            localStorage.removeItem('clawquake_token');
            localStorage.removeItem('clawquake_user');
            window.location.href = '/';
        }

        function authHeaders() {
            return { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' };
        }

        // ── Dashboard Layout Controls ─────────────────────
        const dashboardEl = document.querySelector('.dashboard');
        const statsToggleBtn = document.getElementById('stats-toggle-btn');
        const statsPrefKey = 'clawquake_stats_collapsed';

        function setStatsCollapsed(collapsed) {
            dashboardEl.classList.toggle('stats-collapsed', collapsed);
            statsToggleBtn.textContent = collapsed ? 'Show Stats' : 'Hide Stats';
            statsToggleBtn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
            try { localStorage.setItem(statsPrefKey, collapsed ? '1' : '0'); } catch (e) { }
        }

        statsToggleBtn.addEventListener('click', () => {
            const collapsed = !dashboardEl.classList.contains('stats-collapsed');
            setStatsCollapsed(collapsed);
        });

        const startCollapsed = (() => {
            try { return localStorage.getItem(statsPrefKey) === '1'; }
            catch (e) { return false; }
        })();
        setStatsCollapsed(startCollapsed);

        // ── Live Viewer (QuakeJS Direct + Optional HLS) ─────────────────
        const video = document.getElementById('live-video');
        const directSpectate = document.getElementById('direct-spectate');
        const offlineEl = document.getElementById('video-offline');
        let hlsInstance = null;
        let streamActive = false;
        let streamRetryTimer = null;
        let fallbackTimer = null;
        const enableHls = new URLSearchParams(window.location.search).get('hls') === '1';
        const spectateHost = window.location.hostname || 'localhost';
        const spectateProtocol = window.location.protocol === 'https:' ? 'https:' : 'http:';
        const spectatePort = window.location.protocol === 'https:' ? '' : ':8080';
        const directSpectateUrl = `${spectateProtocol}//${spectateHost}${spectatePort}/`;

        function setOfflineMessage(title, detail = '') {
            offlineEl.innerHTML = `
                <div class="icon">&#9655;</div>
                <div>${escapeHtml(title)}</div>
                <div style="margin-top: 0.5rem; font-size: 0.8rem;">${escapeHtml(detail)}</div>
            `;
            offlineEl.style.display = 'flex';
        }

        function scheduleStreamRetry() {
            if (streamRetryTimer) {
                clearTimeout(streamRetryTimer);
            }
            streamRetryTimer = setTimeout(initStream, 3000);
        }

        function showDirectSpectateFallback(reason = '') {
            video.style.display = 'none';
            directSpectate.style.display = 'block';
            if (!directSpectate.src || directSpectate.src === 'about:blank') {
                directSpectate.src = directSpectateUrl;
            }
            // Ensure keyboard focus goes to the embedded game frame.
            try { directSpectate.focus(); } catch (e) { }
            setOfflineMessage(
                'Direct spectator mode',
                reason || 'Connected to QuakeJS live view.'
            );
            // Keep overlay hidden in direct mode so gameplay stays visible.
            offlineEl.style.display = 'none';
        }

        async function ensureHlsLib() {
            if (window.Hls && typeof window.Hls.isSupported === 'function') {
                return true;
            }
            return await new Promise((resolve) => {
                const tag = document.createElement('script');
                tag.src = '/vendor/hls.min.js?v=1.6.15-local&r=' + Date.now();
                tag.async = true;
                tag.onload = () => resolve(!!(window.Hls && typeof window.Hls.isSupported === 'function'));
                tag.onerror = () => resolve(false);
                document.head.appendChild(tag);
            });
        }

        async function initStream() {
            if (!enableHls) {
                showDirectSpectateFallback('HLS disabled (use ?hls=1 to force HLS mode)');
                return;
            }

            const streamUrl = '/stream/stream.m3u8';
            if (hlsInstance) {
                try { hlsInstance.destroy(); } catch (e) { }
                hlsInstance = null;
            }

            const hasHls = await ensureHlsLib();
            if (hasHls) {
                hlsInstance = new Hls({
                    liveDurationInfinity: true,
                    liveBackBufferLength: 0,
                    maxBufferLength: 5,
                    maxMaxBufferLength: 10,
                });
                hlsInstance.loadSource(streamUrl);
                hlsInstance.attachMedia(video);
                hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => {
                    video.play().catch(() => { });
                    offlineEl.style.display = 'none';
                    video.style.display = 'block';
                    directSpectate.style.display = 'none';
                    streamActive = true;
                    if (fallbackTimer) {
                        clearTimeout(fallbackTimer);
                        fallbackTimer = null;
                    }
                });
                hlsInstance.on(Hls.Events.ERROR, (event, data) => {
                    if (!data.fatal) {
                        return;
                    }
                    streamActive = false;
                    setOfflineMessage('Stream reconnecting...', data.details || 'HLS error');
                    if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                        try { hlsInstance.startLoad(); return; } catch (e) { }
                    }
                    if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                        try { hlsInstance.recoverMediaError(); return; } catch (e) { }
                    }
                    showDirectSpectateFallback(data.details || 'HLS fatal error');
                    scheduleStreamRetry();
                });

                if (fallbackTimer) clearTimeout(fallbackTimer);
                fallbackTimer = setTimeout(() => {
                    if (!streamActive) {
                        showDirectSpectateFallback('HLS startup timeout');
                    }
                }, 8000);
                return;
            }

            if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Safari native HLS
                video.src = streamUrl;
                video.addEventListener('loadedmetadata', () => {
                    video.play().catch(() => { });
                    offlineEl.style.display = 'none';
                    streamActive = true;
                });
            } else {
                // No usable HLS engine in this browser session.
                setOfflineMessage('Player setup failed', 'HLS library unavailable.');
                showDirectSpectateFallback('HLS library unavailable');
                scheduleStreamRetry();
            }
        }

        initStream();

        // ── Live Status Rendering ───────────────────────────
        function renderStatus(data) {
            const mapEl = document.getElementById('map-name');
            const badgeEl = document.getElementById('status-badge');
            const countEl = document.getElementById('player-count');
            const boardEl = document.getElementById('scoreboard');

            if (data.online) {
                mapEl.textContent = data.map_name || 'Unknown Map';
                badgeEl.textContent = 'LIVE';
                badgeEl.className = 'status-badge status-live';
                countEl.textContent = (data.player_count || 0) + ' players';

                if (data.players && data.players.length > 0) {
                    const sorted = [...data.players].sort((a, b) => b.score - a.score);
                    boardEl.innerHTML = sorted.map((p, i) => `
                        <div class="score-row">
                            <span class="rank">${i + 1}</span>
                            <span class="name">${escapeHtml(p.name)}</span>
                            <span class="score">${p.score}</span>
                            <span class="stat">${p.ping}ms</span>
                        </div>
                    `).join('');
                } else {
                    boardEl.innerHTML = '<div class="empty-state">Waiting for players...</div>';
                }
            } else {
                if (streamActive) {
                    mapEl.textContent = mapEl.textContent === '—' ? 'q3dm17' : mapEl.textContent;
                    badgeEl.textContent = 'LIVE';
                    badgeEl.className = 'status-badge status-live';
                    countEl.textContent = 'stream active';
                    boardEl.innerHTML = '<div class="empty-state">Live stream active</div>';
                    return;
                }
                mapEl.textContent = '—';
                badgeEl.textContent = 'OFFLINE';
                badgeEl.className = 'status-badge status-offline';
                countEl.textContent = '0 players';
                boardEl.innerHTML = '<div class="empty-state">Server offline</div>';
            }
        }

        // ── Live Events WebSocket ───────────────────────────
        let eventSocket = null;
        let pingTimer = null;

        function connectEvents() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
            eventSocket = new WebSocket(`${wsProtocol}://${window.location.host}/ws/events`);

            eventSocket.onopen = () => {
                if (pingTimer) clearInterval(pingTimer);
                pingTimer = setInterval(() => {
                    if (eventSocket && eventSocket.readyState === WebSocket.OPEN) {
                        eventSocket.send('ping');
                    }
                }, 20000);
            };

            eventSocket.onmessage = (evt) => {
                try {
                    const msg = JSON.parse(evt.data);
                    const eventType = msg.event_type;
                    const data = msg.data || {};

                    if (eventType === 'status_update') {
                        renderStatus(data);
                    } else if (eventType === 'queue_update') {
                        document.getElementById('queue-count').textContent =
                            `queue: ${data.waiting_entries ?? 0}`;
                    } else if (eventType === 'match_started' || eventType === 'match_ended') {
                        loadHistory();
                        loadLeaderboard();
                    }
                } catch (e) {
                    // ignore malformed events
                }
            };

            eventSocket.onclose = () => {
                if (pingTimer) {
                    clearInterval(pingTimer);
                    pingTimer = null;
                }
                setTimeout(connectEvents, 3000);
            };

            eventSocket.onerror = () => {
                if (eventSocket) {
                    eventSocket.close();
                }
            };
        }

        // ── Leaderboard ─────────────────────────────────────
        async function loadLeaderboard() {
            try {
                const res = await fetch('/api/leaderboard', { headers: authHeaders() });
                if (res.status === 401) { logout(); return; }
                const data = await res.json();
                const el = document.getElementById('leaderboard-body');

                if (data.length === 0) {
                    el.innerHTML = '<div class="empty-state">No bots ranked yet</div>';
                    return;
                }

                el.innerHTML = data.map((bot, i) => `
                    <div class="score-row">
                        <span class="rank">${i + 1}</span>
                        <span class="name">${escapeHtml(bot.name)}</span>
                        <span class="score">${Math.round(bot.elo)}</span>
                        <span class="stat">${bot.wins}W/${bot.losses}L</span>
                    </div>
                `).join('');
            } catch (e) { }
        }

        // ── Match History ───────────────────────────────────
        async function loadHistory() {
            try {
                const res = await fetch('/api/matches', { headers: authHeaders() });
                if (res.status === 401) { logout(); return; }
                const data = await res.json();
                const el = document.getElementById('history-body');

                if (data.length === 0) {
                    el.innerHTML = '<div class="empty-state">No match history</div>';
                    return;
                }

                el.innerHTML = data.map(m => `
                    <div class="match-row">
                        <span class="map">${escapeHtml(m.map_name)}</span>
                        <span class="winner">${m.winner ? escapeHtml(m.winner) : '—'}</span>
                        <span class="date">${new Date(m.started_at).toLocaleDateString()}</span>
                    </div>
                `).join('');
            } catch (e) { }
        }

        // ── Tabs ────────────────────────────────────────────
        function switchTab(name) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[data-tab="${name}"]`).classList.add('active');
            document.getElementById('tab-' + name).classList.add('active');
        }

        // ── Utility ─────────────────────────────────────────
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function pollLiveFallback() {
            try {
                const [statusRes, matchesRes] = await Promise.all([
                    fetch('/api/status'),
                    fetch('/api/matches', { headers: authHeaders() }),
                ]);

                let statusData = null;
                if (statusRes.ok) {
                    statusData = await statusRes.json();
                }
                let matches = [];
                if (matchesRes.ok) {
                    matches = await matchesRes.json();
                }
                const activeMatch = Array.isArray(matches)
                    ? matches.find((m) => !m.ended_at)
                    : null;

                if (statusData && statusData.online) {
                    renderStatus(statusData);
                    return;
                }
                if (activeMatch || streamActive) {
                    renderStatus({
                        online: true,
                        map_name: activeMatch?.map_name || 'q3dm17',
                        players: [],
                        player_count: 0,
                    });
                    return;
                }
                if (statusData) {
                    renderStatus(statusData);
                }
            } catch (e) {
                // best-effort fallback polling
            }
        }

        // ── Init ────────────────────────────────────────────
        connectEvents();
        loadLeaderboard();
        loadHistory();
        pollLiveFallback();
        // Refresh leaderboard every 30 seconds
        setInterval(loadLeaderboard, 30000);
        // Refresh history every 30 seconds
        setInterval(loadHistory, 30000);
        // Fallback status polling when websocket/status is unreliable
        setInterval(pollLiveFallback, 5000);
    </script>
</body>

</html>
